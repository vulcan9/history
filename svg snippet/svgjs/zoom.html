<!DOCTYPE html>

<html lang="ko" xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8" />
	<title>svg.js 라이브러리 test</title>

    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>

    <!--
    <script src="https://s3-eu-west-1.amazonaws.com/svgjs/svg.js" type="text/javascript" charset="utf-8"></script>
    <script src="http://svgjs.com/javascripts/svg.draggable.js" type="text/javascript" charset="utf-8"></script>
    <script src="http://svgjs.com/javascripts/svg.easing.js" type="text/javascript" charset="utf-8"></script>
    -->
    <script src="src/svg.js"></script>
    <script src="src/svg.easing.js"></script>
    
    <style>
        body, div{font-size:0;}
        svg {
            font-size: 12px;
            border: 1px dashed #000;
            background: #ddd;
        }
        g {
            pointer-events: bounding-box;
        }
            g.viewport .background {
                opacity: 0.1;
                fill: #777;
            }
                g.viewport .background:hover {
                    opacity: 0.2;
                }
            g.gArea .background {
                opacity: 0.5;
                fill: #999;
            }

                g.gArea .background:hover {
                    opacity: 1;
                }

        text {
            pointer-events: none;
        }
        rect {
            /*fill: #b6ff00;*/
            stroke-width: 1px;
            cursor: pointer;
            opacity: 0.5;
        }
            rect:hover {
                opacity: 1;
            }

    </style>
</head>
<body>

	<!--
	<svg width="50" height="50">
		<circle cx="25" cy="25" r="25" fill="purple" />
	</svg>
	-->
	<div id="container" class="aa" style="
	position: absolute; background-color:#EEE; padding:10px;
    left: 20px;
    top: 20px;"></div>

	<script src="../_unit/ScaleMode.js"></script>
	
    <script>

        function out() {
            console.log.apply(console, arguments);
        }

        var w = 700, h = 500;
        var svg;
        var viewport;
        var padding = 10;

		// 현재 포커싱 받는 객체(group, viewport)
        var currentFocus;
		// 마지막 포커싱 받는 객체(group, viewport)
        var lastFocus;

        !function () {

            //--------------------------------
            // SVG
            //--------------------------------

            if (SVG.supported == false) {
                alert('SVG not supported');
                return;
            }

            svg = SVG("container").fixSubPixelOffset().size(w, h)
                //.style("margin-bottom", "10px");

            svg.on("mousedown", function (e) {
                if (e.defaultPrevented) return;
                out("# svg 클릭");
                focus(this);
            });

            viewport = svg.group().addClass("viewport")
                .move(padding, padding);
            viewport.rect().addClass("background")
                .size(w - padding * 2, h - padding * 2);

            viewport.on("mousedown", function (e) {
                if (e.defaultPrevented) return;
                e.preventDefault();
                out("# viewport 클릭");
                focus(this);
            });

            // group 이동 방법
            //var rect = svg.rect().size(100, 100).fill("#FF0");
            //group.add(rect);

            //--------------------------------
            // Group Container 1
            //--------------------------------
            
            var group = createGroup(viewport, 299, 199).translate(50, 50);
            var rect = createElement(group, "rect").fill("#FF0").size(100, 100);
            var rect = createElement(group, "rect").fill("#F00").move(100, 100);

            //--------------------------------
            // Group Container 2
            //--------------------------------

            var group = createGroup(viewport, 160, 160).translate(400, 200).rotate(45);
            var rect = createElement(group, "rect").fill("#FF0").size(80, 80);
            var rect = createElement(group, "rect").fill("#F00").size(80, 80).move(80, 80);

        	// 회전 전 위치
        	//svg.add(group.first().clone().fill("#F00").style("opacity", 0.2).translate(400 + padding, 200 + padding)).style({"pointer-events": "none"});

            //--------------------------------
            // Group Container 3
            //--------------------------------

            var group = createGroup(viewport, 160, 100).translate(300, 100).rotate(80);
            var rect = createElement(group, "rect").fill("#FF0").size(80, 50);
            var rect = createElement(group, "rect").fill("#F00").size(80, 50).move(80, 50);

        	// 회전 전 위치
        	//svg.add(group.first().clone().fill("#FF0").style("opacity", 0.2).translate(300 + padding, 100 + padding)).style({ "pointer-events": "none" });

            ///////////////////////////////////
            // Function
            ///////////////////////////////////

            function createGroup(parentGroup, w, h) {
                var group = parentGroup.group().addClass("gArea")

                // 기본 크기 표시
                //group.rect().fill("none")
                group.rect().addClass("background")
                    //.stroke({ color: '#f06', width: 1, opacity: 0.5 })
                    //.size(w-1, h-1).move(0.5, 0.5);
                    .size(w, h);

                group.on("mousedown", function (e) {
                    if (e.defaultPrevented) return;
                    e.preventDefault();
                    out("# parent Group 클릭");
                    focus(this);
                });

                return group;
            }
            
            // var rect = createElement(g, "rect");
            function createElement(parent, type) {
                var el = parent[type]().size(50, 50).fill("#F00");
                
                el.on("mousedown", function (e) {
                    e.preventDefault();
                    out("# Element 클릭");
                    focus(this);
                });

                return el;
            }
            
            // var use = group.use(createSymbol("rect"))
            function createSymbol(type) {
                var el = svg.defs()[type](50, 50).fill("#f09");
                return el;
            }

            //--------------------------------
            // FOCUS
            //--------------------------------

            var currentScale = 1;

            function focus(instance) {
                
                //out(instance);
                var group = getFocusGroup(instance);

                var rollback = (group != instance.parent);
                if (rollback) {
                	// 원상태로 되돌리기
                	lastFocus = currentFocus;
                    currentFocus = viewport;
                    initZoom(group);
                    return;
                }

                if (group == currentFocus) return;
                lastFocus = currentFocus;
                currentFocus = group;

                // ScaleMode.SCALE_WINDOW
                var source = getBoundary(group);
                
                var scaleMode = new ScaleMode({
                    sourceWidth: source.width,
                    sourceHeight: source.height,
                    compareWidth: w - padding*2,
                    compareHeight: h - padding*2
                });

                // scale을 계산한다.
                scaleMode.scale(ScaleMode.SCALE_WINDOW);
                var scale = scaleMode.scale();
                out("scale : ", scale);

                // Center
                //var pos = getPosition(group, scale);
                //out("position을 계산한다.", pos, source);

                // zoom 적용
                zoom(group, scale);
            }

            function getFocusGroup(instance) {
                var group;

                if (instance == svg) {
                    group = instance.first();

                } else if (instance.hasClass("viewport")) {
                    out("// svg (viewport인 경우)");
                    group = instance;

                } else {
                    if (instance.hasClass("gArea")) {
                        out("// group인 경우");
                        group = instance;

                    } else if (instance.parent.hasClass("gArea")) {
                        out("// element인 경우");
                        group = instance.parent;

                    } else {
                        throw "# FOCUS 예외";
                        return;
                    }
                }
                return group;
            }
        }();

        //--------------------------------
        // Boundary
        // Focus받는 객체의 scale&position 계산을 위해 사용될 boundary를 결정
        //--------------------------------

        var config_fixedBoundary = false;

        // scale 및 위치 설정을 위해 group의 boundary 값을 리턴
        function getBoundary(group) {

            if (config_fixedBoundary) {
                // background 크기(Paper 영역) 기준으로 계산
                // group영역을 넘쳐난 컨텐츠를 가진 경우 확대시 화면에 포함되지 않음
                var box = group.first().bbox();
            } else {
                // group 전체가 차지하는 크기 기준으로 계산할때
                var box = group.bbox();
            }
            
            return box;
        }

        function getWidth(group) {
            return getBoundary(group).width;
        }

        function getHeight(group) {
            return getBoundary(group).height;
        }

        //--------------------------------
        // Position
        // 확대 또는 축소된 화면에서 Focus된 group이 중앙에 위치되도록 하기위해 이동할 거리
        //--------------------------------

		/*
        function getPosition(group, scale) {

            var box = group.bbox();
            var x = box.x * scale - padding;
            var y = box.y * scale - padding;

            // center
            var frame = viewport.bbox();

            var viewportWidth = frame.width / viewport.trans.scaleX;
            var viewportHeight = frame.height / viewport.trans.scaleY;

            var groupWidth = getWidth(group) * scale;
            var groupHeight = getHeight(group) * scale;

            var dx = (viewportWidth - groupWidth) / 2;
            var dy = (viewportHeight - groupHeight) / 2;

            x = x - dx;
            y = y - dy;
            return {x:x, y:y};
        }
		*/

        //--------------------------------
        // move & scale
        //--------------------------------

        // scale = 1로 되돌린 후 다시 zomm 효과를 적용할지 여부
        var config_rollbackEffect = false;

        function initZoom(group) {
            var scale = 1;
            zoom(group, scale);
        }

        var _fx;

        function zoom(group, scale) {
            if (_fx) {
                _fx.stop();
            }

            var duration = 1000;

        	// Rotate
            var rotation = group.trans.rotation;

            if (viewport.trans.scaleX == 1 || !config_rollbackEffect) {
                
                /* 확인된 코드 (rotate 수정 필요)
                _fx = viewport.animate(duration, SVG.easing.backOut);
                _fx.rotate(-rotation).scale(scale).translate(-x, -y).after(endEffect);
                //*/
                
            	// 중심점 이동하여 회전
                //viewport.circle(1).fill("#000").center(cx, cy);
                
                var box = currentFocus.bbox();
                var cx = box.cx + padding;
                var cy = box.cy + padding;
                var sx = sy = scale;

                var r = -rotation / 180 * Math.PI;
                var cos = Math.cos(r);
                var sin = Math.sin(r);

                /*
                원하는 중심으로 좌표축을 이동 --> 회전시키고 --> 다시 원래의 좌표축으로
                * [-이동] --> [회전] --> [이동] 인 행렬식으로는 다음과 같이 나타남

                [회전]        [-이동]        [회전][-이동]
                | cos -sin 0 || 1 0 -cx |    | cos -sin -cx*cos+cy*sin |
                | sin  cos 0 || 0 1 -cy | =  | sin  cos -cx*sin-cy*cos |
                |   0    0 1 || 0 0   1 |    |   0    0              1 |

                [이동]    [회전][-이동]
                | 1 0 cx || cos -sin -cx*cos+cy*sin |   | cos  -sin  -cx*cos+cy*sin + cx |
                | 0 1 cy || sin  cos -cx*sin-cy*cos | = | sin   cos  -cx*sin-cy*cos + cy |
                | 0 0  1 ||   0    0              1 |   |   0     0                    1 |
                
                .transform({
                    a: cos,
                    b: sin,
                    c: -sin,
                    d: cos,
                    e: -cx*cos+cy*sin+cx,
                    f: -cx*sin-cy*cos+cy
                })

                // 특정위치를 중심으로하는  확대,회전 --> 연산 순서에 주의한다 (변환의 순서에 따라 변환 결과가 다르다.)
                // 순서는 [ x0 y0 1 ] 벡터에 가까운 행렬부터 곱한다고 생각하면 된다

                원하는 중심으로 좌표축을 (확대전 scale 적용된 만큼)이동 --> 확대, 회전 시키고 --> 다시 원래의 좌표축으로 (확대후 scale 적용된 만큼) 이동
                * [-이동] --> [확대] --> [회전] --> [이동] 인 행렬식으로는 다음과 같이 나타남

                // [특정위치를 중심으로하는 확대, 회전] = 
                //     [이동]    [회전]        [확대]     [-이동]     * [좌표]
                |x1|   | 1 0 cx || cos -sin 0 || sx  0 0 || 1 0 -cx |   |x0|
                |y1| = | 0 1 cy || sin  cos 0 ||  0 sy 0 || 0 1 -cy | * |y0|
                | 1|   | 0 0  1 ||   0    0 1 ||  0  0 1 || 0 0   1 |   | 1|
                ----  ----------------------------------------------  -----

                http://aslike.egloos.com/viewer/2898232
                http://blog.naver.com/jjoheejea/150166157777

                [확대]     [-이동]       [확대][-이동]
                | sx  0 0 || 1 0 -cx |   | sx  0 -sx*cx |
                |  0 sy 0 || 0 1 -cy | = |  0 sy -sy*cy |
                |  0  0 1 || 0 0   1 |   |  0  0      1 |

                [회전]        [확대][-이동]      [회전][확대][-이동]
                | cos -sin 0 || sx  0 -sx*cx |   | sx*cos  -sy*sin  cos*(-sx*cx)-sin*(-sy*cy) = SX |
                | sin  cos 0 ||  0 sy -sy*cy | = | sx*sin   sy*cos  sin*(-sx*cx)+cos*(-sy*cy) = SY |
                |   0    0 1 ||  0  0      1 |   |      0        0                               1 |

                _fx.transform({
                	a: sx * cos,
                	b: sx * sin,
                	c: -sy * sin,
                	d: sy * cos,
                	e: cos * (-sx * cx) - sin * (-sy * cy),
                	f: sin * (-sx * cx) + cos * (-sy * cy)
                })

                [이동]         [회전][확대][-이동]       [이동][회전][확대][-이동]
                | 1 0 cx = CX || sx*cos  -sy*sin  SX |   | sx*cos  -sy*sin  SX+CX | 
                | 0 1 cy = CY || sx*sin   sy*cos  SY | = | sx*sin   sy*cos  SY+CY |
                | 0 0       1 ||      0        0  1  |   |      0        0      1 |
                
                _fx.transform({
                	a: sx * cos,
                	b: sx * sin,
                	c: -sy * sin,
                	d: sy * cos,
                	e: SX + CX,
                	f: SY + CY
                })
				
				// 마지막 화면 중심으로 이동
                [중심간격][이동][회전][확대][-이동]
				| 1 0 dx || sx*cos  -sy*sin  SX+CX |   | sx*cos  -sy*sin  SX+CX+dx | 
                | 0 1 dy || sx*sin   sy*cos  SY+CY | = | sx*sin   sy*cos  SY+CY+dy |
                | 0 0  1 ||      0        0      1 |   |      0        0         1 |

                */

                var SX = cos * (-sx * cx) - sin * (-sy * cy);
                var SY = sin * (-sx * cx) + cos * (-sy * cy);
                var CX = cx;
                var CY = cy;

                if(currentFocus == viewport){
                	CX += padding;
                	CY += padding;
                }

            	// 중심점간 거리만큼 이동시켜줌
                var vBox = viewport.bbox();
                var dx = vBox.cx - cx;
                var dy = vBox.cy - cy;

            	// SVG.easing
            	// https://github.com/wout/svg.easing.js
            	// http://easings.net/
                _fx = viewport.animate(duration, SVG.easing.backOut);
                _fx.transform({
                	a: sx * cos,
                	b: sx * sin,
                	c: -sy * sin,
                	d: sy * cos,
                	e: SX + CX + dx,
                	f: SY + CY + dy
                })
				.after(endEffect);

            } else {
                // 초기 상태로 복귀한 후 Zoom 적용
                _fx = viewport.animate(duration, SVG.easing.backInOut);

                _fx.scale(1).translate(padding, padding).rotate(-rotation).after(function () {
                    _fx.stop();
                    _fx = viewport.animate(duration, SVG.easing.backOut);
                    _fx.scale(scale).translate(-x, -y).after(endEffect);
                });
            }

            function endEffect() {
                // 중복 실행 방지되도록 수정
                _fx.stop();

                out("end Effect : ", scale);
                _fx = null;
            }
        }

        //--------------------------------
        // Drag 화면이동 기능
        //--------------------------------








    </script>
</body>
</html>