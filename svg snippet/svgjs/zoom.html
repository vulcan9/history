<!DOCTYPE html>

<html lang="ko" xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8" />
	<title>svg.js 라이브러리 test</title>

    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>

    <!--
    <script src="https://s3-eu-west-1.amazonaws.com/svgjs/svg.js" type="text/javascript" charset="utf-8"></script>
    <script src="http://svgjs.com/javascripts/svg.draggable.js" type="text/javascript" charset="utf-8"></script>
    <script src="http://svgjs.com/javascripts/svg.easing.js" type="text/javascript" charset="utf-8"></script>
    -->
    <script src="src/svg.js"></script>
    <script src="src/svg.easing.js"></script>
    
    <style>
        body, div{font-size:0;}
        svg {
            font-size: 12px;
            border: 1px dashed #000;
            background: #ddd;
        }
        g {
            pointer-events: bounding-box;
        }
            g.viewport .background {
                opacity: 0.1;
                fill: #777;
            }
                g.viewport .background:hover {
                    opacity: 0.2;
                }
            g.gArea .background {
                opacity: 0.5;
                fill: #999;
            }

                g.gArea .background:hover {
                    opacity: 1;
                }

        text {
            pointer-events: none;
        }
        rect {
            /*fill: #b6ff00;*/
            stroke-width: 1px;
            cursor: pointer;
            opacity: 0.5;
        }
            rect:hover {
                opacity: 1;
            }

    </style>
</head>
<body>

	<!--
	<svg width="50" height="50">
		<circle cx="25" cy="25" r="25" fill="purple" />
	</svg>
	-->
	<div id="container" class="aa" style="
	position: absolute; background-color:#EEE; padding:10px;
    left: 20px;
    top: 20px;"></div>

	<script src="../_unit/ScaleMode.js"></script>
	
    <script>

        function out() {
            console.log.apply(console, arguments);
        }

        var w = 700, h = 500;
        var svg;
        var viewport;
        var padding = 10;

        // 현재 포커싱 받는 객체(group)
        var currentFocus;

        !function () {

            //--------------------------------
            // SVG
            //--------------------------------

            if (SVG.supported == false) {
                alert('SVG not supported');
                return;
            }

            svg = SVG("container").fixSubPixelOffset().size(w, h)
                //.style("margin-bottom", "10px");

            svg.on("mousedown", function (e) {
                if (e.defaultPrevented) return;
                out("# svg 클릭");
                focus(this);
            });

            viewport = svg.group().addClass("viewport")
                .move(padding, padding);
            viewport.rect().addClass("background")
                .size(w - padding * 2, h - padding * 2);

            viewport.on("mousedown", function (e) {
                if (e.defaultPrevented) return;
                e.preventDefault();
                out("# viewport 클릭");
                focus(this);
            });

            // group 이동 방법
            //var rect = svg.rect().size(100, 100).fill("#FF0");
            //group.add(rect);

            //--------------------------------
            // Group Container 1
            //--------------------------------
            
            var group = createGroup(viewport, 299, 199).translate(50, 50);
            var rect = createElement(group, "rect").fill("#FF0").size(100, 100);
            var rect = createElement(group, "rect").fill("#F00").move(100, 100);

            //--------------------------------
            // Group Container 2
            //--------------------------------

            var group = createGroup(viewport, 160, 160).translate(400, 200).rotate(45);
            var rect = createElement(group, "rect").fill("#FF0").size(80, 80);
            var rect = createElement(group, "rect").fill("#F00").size(80, 80).move(80, 80);

svg.add(group.first().clone().fill("#F00").style("opacity", 0.2).translate(400 + padding, 200 + padding)).style({"pointer-events": "none"});

            //--------------------------------
            // Group Container 3
            //--------------------------------

            var group = createGroup(viewport, 160, 100).translate(300, 100).rotate(30);
            var rect = createElement(group, "rect").fill("#FF0").size(80, 50);
            var rect = createElement(group, "rect").fill("#F00").size(80, 50).move(80, 50);

svg.add(group.first().clone().fill("#FF0").style("opacity", 0.2).translate(300 + padding, 100 + padding)).style({ "pointer-events": "none" });

            ///////////////////////////////////
            // Function
            ///////////////////////////////////

            function createGroup(parentGroup, w, h) {
                var group = parentGroup.group().addClass("gArea")

                // 기본 크기 표시
                //group.rect().fill("none")
                group.rect().addClass("background")
                    //.stroke({ color: '#f06', width: 1, opacity: 0.5 })
                    //.size(w-1, h-1).move(0.5, 0.5);
                    .size(w, h);

                group.on("mousedown", function (e) {
                    if (e.defaultPrevented) return;
                    e.preventDefault();
                    out("# parent Group 클릭");
                    focus(this);
                });

                return group;
            }
            
            // var rect = createElement(g, "rect");
            function createElement(parent, type) {
                var el = parent[type]().size(50, 50).fill("#F00");
                
                el.on("mousedown", function (e) {
                    e.preventDefault();
                    out("# Element 클릭");
                    focus(this);
                });

                return el;
            }
            
            // var use = group.use(createSymbol("rect"))
            function createSymbol(type) {
                var el = svg.defs()[type](50, 50).fill("#f09");
                return el;
            }

            //--------------------------------
            // FOCUS
            //--------------------------------

            var currentScale = 1;

            function focus(instance) {
                
                //out(instance);
                var group = getFocusGroup(instance);

                var rollback = (group != instance.parent);
                if (rollback) {
                    // 원상태로 되돌리기
                    currentFocus = viewport;
                    initZoom(group);
                    return;
                }

                if (group == currentFocus) return;
                currentFocus = group;

                // ScaleMode.SCALE_WINDOW
                var source = getBoundary(group);
                
                var scaleMode = new ScaleMode({
                    sourceWidth: source.width,
                    sourceHeight: source.height,
                    compareWidth: w - padding*2,
                    compareHeight: h - padding*2
                });

                // scale을 계산한다.
                scaleMode.scale(ScaleMode.SCALE_WINDOW);
                var scale = scaleMode.scale();
                out("scale : ", scale);

                // Rotate
                var rotation = group.trans.rotation;

                // Center
                var pos = getPosition(group, scale);
                out("position을 계산한다.", pos, source);

                // zoom 적용
                zoom(group, scale, pos.x, pos.y, rotation);
            }

            function getFocusGroup(instance) {
                var group;

                if (instance == svg) {
                    group = instance.first();

                } else if (instance.hasClass("viewport")) {
                    out("// svg (viewport인 경우)");
                    group = instance;

                } else {
                    if (instance.hasClass("gArea")) {
                        out("// group인 경우");
                        group = instance;

                    } else if (instance.parent.hasClass("gArea")) {
                        out("// element인 경우");
                        group = instance.parent;

                    } else {
                        throw "# FOCUS 예외";
                        return;
                    }
                }
                return group;
            }
        }();

        //--------------------------------
        // Boundary
        // Focus받는 객체의 scale&position 계산을 위해 사용될 boundary를 결정
        //--------------------------------

        var config_fixedBoundary = false;

        // scale 및 위치 설정을 위해 group의 boundary 값을 리턴
        function getBoundary(group) {

            if (config_fixedBoundary) {
                // background 크기(Paper 영역) 기준으로 계산
                // group영역을 넘쳐난 컨텐츠를 가진 경우 확대시 화면에 포함되지 않음
                var box = group.first().bbox();
            } else {
                // group 전체가 차지하는 크기 기준으로 계산할때
                var box = group.bbox();
            }
            
            return box;
        }

        function getWidth(group) {
            return getBoundary(group).width;
        }

        function getHeight(group) {
            return getBoundary(group).height;
        }

        //--------------------------------
        // Position
        // 확대 또는 축소된 화면에서 Focus된 group이 중앙에 위치되도록 하기위해 이동할 거리
        //--------------------------------

        function getPosition(group, scale) {

            var box = group.bbox();
            var x = box.x * scale - padding;
            var y = box.y * scale - padding;

            // center
            var frame = viewport.bbox();

            var viewportWidth = frame.width / viewport.trans.scaleX;
            var viewportHeight = frame.height / viewport.trans.scaleY;

            var groupWidth = getWidth(group) * scale;
            var groupHeight = getHeight(group) * scale;

            var dx = (viewportWidth - groupWidth) / 2;
            var dy = (viewportHeight - groupHeight) / 2;

            x = x - dx;
            y = y - dy;
            return {x:x, y:y};
        }

        //--------------------------------
        // move & scale
        //--------------------------------

        // scale = 1로 되돌린 후 다시 zomm 효과를 적용할지 여부
        var config_rollbackEffect = false;

        function initZoom(group) {
            //if (viewport.trans.scaleX == 1) return;
            var scale = 1;
            var x = -padding;
            var y = -padding;
            var rotation = 0;
            zoom(group, 1, x, y, rotation);
        }

        var _fx;

        /*
        // SVG.easing
        // https://github.com/wout/svg.easing.js
        // http://easings.net/
        */





        //_fx = viewport.animate(100, SVG.easing.backOut);
        //_fx.rotate(0, 0, 0);




        function zoom(group, scale, x, y, rotation) {
            if (_fx) {
                _fx.stop();
            }

            var duration = 1000;
            if (viewport.trans.scaleX == 1 || !config_rollbackEffect) {
                
                /* 확인된 코드 (rotate 수정 필요)
                _fx = viewport.animate(duration, SVG.easing.backOut);
                _fx.rotate(-rotation).scale(scale).translate(-x, -y).after(endEffect);
                //*/
                

                var box = group.bbox();
                var cx = box.cx, cy = box.cy;
                
                var vBox = viewport.bbox();
                var vcx = vBox.cx, vcy = vBox.cy;

                out(cx, cy, vcx, vcy);
                viewport.circle(6).fill("#000").center(cx, cy);
                // 중심점 이동하여 회전
                //viewport.rotate(-rotation, cx + padding, cy + padding)


                /*
                원하는 중심으로 좌표축을 이동 --> 회전시키고 --> 다시 원래의 좌표축으로
                * [-이동] --> [회전] --> [이동] 인 행렬식으로는 다음과 같이 나타남

                [회전]        [-이동]        [회전][-이동]
                | cos -sin 0 || 1 0 -cx |    | cos -sin -cx*cos+cy*sin |
                | sin  cos 0 || 0 1 -cy | =  | sin  cos -cx*sin-cy*cos |
                |   0    0 1 || 0 0   1 |    |   0    0              1 |

                [이동]    [회전][-이동]
                | 1 0 cx || cos -sin -cx*cos+cy*sin |   | cos  -sin  -cx*cos+cy*sin + cx |
                | 0 1 cy || sin  cos -cx*sin-cy*cos | = | sin   cos  -cx*sin-cy*cos + cy |
                | 0 0  1 ||   0    0              1 |   |   0     0                    1 |
                */
                
                _fx = viewport.animate(duration, SVG.easing.backOut);


                var r = -rotation / 180 * Math.PI;
                var cos = Math.cos(r);
                var sin = Math.sin(r);
                var cx = cx + padding;
                var cy = cy + padding;
                var sx = sy = scale;

                /*
                .transform({
                    a: cos,
                    b: sin,
                    c: -sin,
                    d: cos,
                    e: -cx*cos+cy*sin+cx,
                    f: -cx*sin-cy*cos+cy
                })
                */
                
                /*
                // 특정위치를 중심으로하는  확대,회전 --> 연산 순서에 주의한다 (변환의 순서에 따라 변환 결과가 다르다.)
                // 순서는 [ x0 y0 1 ] 벡터에 가까운 행렬부터 곱한다고 생각하면 된다

                원하는 중심으로 좌표축을 (확대전 scale 적용된 만큼)이동 --> 확대, 회전 시키고 --> 다시 원래의 좌표축으로 (확대후 scale 적용된 만큼) 이동
                * [-이동] --> [확대] --> [회전] --> [이동] 인 행렬식으로는 다음과 같이 나타남

                // [특정위치를 중심으로하는 확대, 회전] = 
                //     [이동]    [회전]        [확대]     [-이동]     * [좌표]
                |x1|   | 1 0 cx || cos -sin 0 || sx  0 0 || 1 0 -cx |   |x0|
                |y1| = | 0 1 cy || sin  cos 0 ||  0 sy 0 || 0 1 -cy | * |y0|
                | 1|   | 0 0  1 ||   0    0 1 ||  0  0 1 || 0 0   1 |   | 1|
                ----  ----------------------------------------------  -----
                http://aslike.egloos.com/viewer/2898232
                http://blog.naver.com/jjoheejea/150166157777


                [확대]     [-이동]       [확대][-이동]
                | sx  0 0 || 1 0 -cx |   | sx  0 -sx*cx |
                |  0 sy 0 || 0 1 -cy | = |  0 sy -sy*cy |
                |  0  0 1 || 0 0   1 |   |  0  0      1 |

                [회전]        [확대][-이동]      [회전][확대][-이동]
                | cos -sin 0 || sx  0 -sx*cx |   | sx*cos  -sy*sin  cos*(-sx*cx)-sin*(-sy*cy) = SX |
                | sin  cos 0 ||  0 sy -sy*cy | = | sx*sin   sy*cos  sin*(-sx*cx)+cos*(-sy*cy) = SY |
                |   0    0 1 ||  0  0      1 |   |      0        0                          1      |

                [이동]    [회전][확대][-이동]       [이동][회전][확대][-이동]
                | 1 0 cx*sx = CX || sx*cos  -sy*sin  SX |   | sx*cos  -sy*sin  SX+CX | 
                | 0 1 cy*sy = CY || sx*sin   sy*cos  SY | = | sx*sin   sy*cos  SY+CY |
                | 0 0  1 ||      0        0  1  |   |      0        0      1 |
                
                //scale 적용 - 연산 다시 해야함
                //var sx = sy = 1;
                _fx.transform({
                    a: sx * cos,
                    b: sx * sin,
                    c: sy * (-sin),
                    d: sy * cos,
                    e: cos*(-sx*cx)-sin*(-sy*cy) + cx*sx,
                    f: sin*(-sx*cx)+cos*(-sy*cy) + cy*sy
                })
                */

                /*
                // 특정위치를 중심으로하는  확대,회전 --> 연산 순서에 주의한다 (변환의 순서에 따라 변환 결과가 다르다.)
                // 순서는 [ x0 y0 1 ] 벡터에 가까운 행렬부터 곱한다고 생각하면 된다

                확대 --> 원하는 중심으로 좌표축을 (scale 적용된 만큼)이동 --> 회전 --> 다시 원래의 좌표축으로 (scale 적용된 만큼) 이동
                * [확대] --> [-이동] --> [회전] --> [이동] 인 행렬식으로는 다음과 같이 나타남

                // [특정위치를 중심으로하는 확대, 회전] = 
                //     [이동]       [회전]        [-이동]       [확대]          * [좌표]
                |x1|   | 1 0 cx*sx || cos -sin 0 || 1 0 -cx*sx || sx  0 0 |   |x0|
                |y1| = | 0 1 cy*sy || sin  cos 0 || 0 1 -cy*sy ||  0 sy 0 | * |y0|
                | 1|   | 0 0     1 ||   0    0 1 || 0 0      1 ||  0  0 1 |   | 1|
                ----  ----------------------------------------------  -----
                http://aslike.egloos.com/viewer/2898232
                http://blog.naver.com/jjoheejea/150166157777


                [-이동]       [확대]        [-이동][확대]
                | 1 0 -cx*sx || sx  0 0 |   | sx  0 -cx*sx |
                | 0 1 -cy*sy ||  0 sy 0 | = |  0 sy -cy*sy |
                | 0 0      1 ||  0  0 1 |   |  0  0      1 |

                [회전]        [-이동][확대]      [회전][-이동][확대]
                | cos -sin 0 || sx  0 -sx*cx |   | sx*cos  -sy*sin  cos*(-sx*cx)-sin*(-sy*cy) = SX |
                | sin  cos 0 ||  0 sy -sy*cy | = | sx*sin   sy*cos  sin*(-sx*cx)+cos*(-sy*cy) = SY |
                |   0    0 1 ||  0  0      1 |   |      0        0                          1      |

                [이동]            [회전][-이동][확대]       [이동][회전][-이동][확대]
                | 1 0 cx*sx = CX || sx*cos  -sy*sin  SX |   | sx*cos  -sy*sin  SX+CX | 
                | 0 1 cy*sy = CY || sx*sin   sy*cos  SY | = | sx*sin   sy*cos  SY+CY |
                | 0 0          1 ||      0        0   1 |   |      0        0      1 |
                
                */

                //scale 적용 - 연산 다시 해야함
                //var sx = sy = 1;
                _fx.transform({
                    a: sx * cos,
                    b: sx * sin,
                    c: sy * (-sin),
                    d: sy * cos,
                    e: cos * (-sx * cx) - sin * (-sy * cy) + cx * sx,
                    f: sin * (-sx * cx) + cos * (-sy * cy) + cy * sy
                })






























                //c = currentFocus.bbox()
                //viewport.rotate(20, c.cx, c.cy)
                //viewport.circle(6).fill("#000").center(c.cx, c.cy);

                return;

                //return;

                _fx = viewport.animate(duration, SVG.easing.backOut)
                //_fx.scale(scale).translate(-x, -y).rotate(-rotation, cx + 10, cy + 10).after(endEffect);
                .rotate(-rotation, cx, cy)
                .translate(-cx, -cy)

                var last = viewport.last()
                if(last.type == "ellipse"){
                    last.remove();
                }

                //out(group == viewport);

                //viewport.rotate(-45, 480, 280)
                if (currentFocus != viewport) {
                    viewport.circle(6).fill("#000").center(cx, cy);
                } else {
                    //viewport.circle(6).fill("#F00").center(cx, cy);
                }
                
                /*

                
            	
            	//함수의 호출 순서는 변환에 영향을 준다
            	//가령, 이동 후에 회전을 하고 싶다고 한다면
            	//rotate() 함수를 먼저 호출하고 그 이후에 translate() 함수를 호출한다

            	var r = rotation / 180 * Math.PI;
                //a.transform({ matrix: "1,0,0,1,10,0" })
            	var cos = Math.cos(r);
            	var sin = Math.sin(r);

            	out(cx, cy, group.node, viewport.node);
                _fx = viewport.animate(duration, SVG.easing.backOut);

                _fx.translate(x, y).scale(scale).rotate(-rotation, cx, cy).translate(-x, -y).after(function () {
                	endEffect();
                });

				
                var cx:int = target.width/2;
                var cy:int = target.height/2;
                var a:int = 15;
                var m:Matrix = event.target.transform.matrix;
                var p:Point = m.transformPoint(new Point(cx, cy));
                m.translate(-p.x, -p.y);
                m.rotate(a*(Math.PI/180));
                m.translate(p.x, p.y);
                target.transform.matrix = m;

                이 소스는 target의 가운데(x, y)를 중심으로 회전하는 코드다. 
				*/











            } else {
                // 초기 상태로 복귀한 후 Zoom 적용
                _fx = viewport.animate(duration, SVG.easing.backInOut);

                _fx.scale(1).translate(padding, padding).rotate(-rotation).after(function () {
                    _fx.stop();
                    _fx = viewport.animate(duration, SVG.easing.backOut);
                    _fx.scale(scale).translate(-x, -y).after(endEffect);
                });
            }

            function endEffect() {
                // 중복 실행 방지되도록 수정
                _fx.stop();

                out("endEffect : ", scale);
                _fx = null;
            }
        }

        //--------------------------------
        // Drag 화면이동 기능
        //--------------------------------

        //b = svg.rect().size(100, 100).fill("#0FF").style("opacity", 0.2).rotate(45, 10, 10);
        //out("b : ",b.bbox());
        //b.rotate(45, 0, 0);
        //b.move(100, 0);

        //--------------------------------
        // Rotation된 화면 표시
        //--------------------------------

        //a = svg.rect().size(100, 100).fill("#F00").style("opacity", 0.2);
        //a.rotate(45, 0, 0)//.move(25,0);

        /*
        // http://belouder.blog.me/40163175484
        // http://blog.jidolstar.com/463

		matrix[1,2,3,4,5,6] ==>
         | x1 |   | 1 3 5 || x |   | a c e || x |   | Sx Tx dx || x |
         | y1 | = | 2 4 6 || y | = | b d f || y | = | Ty Sy dy || y |
         |  1 |   | 0 0 1 || 1 |   | 0 0 1 || 1 |   | 0  0   1 || 1 |
        
        // rotate인 경우
        | cos -sin 0 |
        | sin  cos 0 |
        |   0    0 1 |

        // 중심점 이동->회전->확대/축소를 적용
        [ sx * cosθ,  sx * sinθ, -cx * sx * cosθ - cy * sx * sinθ], 
        [-sy * sinθ,  sy * cosθ,  cx * sy * sinθ + cy * sy * cosθ], 
        [          0,           0,                                  1]
        

        이동      회전         확대/축소
        | 1 0 -cx |  cos sin 0 | sx  0 0 |
        | 0 1 -cy | -sin cos 0 |  0 sy 0 |
        | 0 0 1   |    0   0 1 |  0  0 1 |
        ==>
        |  cos sin -cx | sx  0 0 |
        | -sin cos -cy |  0 sy 0 |
        |    0   0   1 |  0  0 1 |
        ==>
        |  cos*sx sin*sy -cx |
        | -sin*sx cos*sy -cy |
        |       0      0   1 |

        */
        //a.transform({matrix:"1,0,0,1,0,0"})

        /*
        var r = 45 / 180 * Math.PI;
        //a.transform({ matrix: "1,0,0,1,10,0" })
        var cos = Math.cos(r);
        var sin = Math.sin(r);
        var sx = sy = 1;
        var cx = cy = 10;
        */

        /*
        a.transform({
            a: (sx * cos), c: (sx * sin), e: (-cx * sx * cos - cy * sx * sin),
            b: (-sy * sin), d: (sy * cos), f: (cx * sy * sin + cy * sy * cos)
        });
        
        a.transform({
            a: (sx * cos), c: (sy * sin), e: (-cx * sx * cos + cy * sy * sin),
            b: (-sx * sin), d: (sy * cos), f: (-cx * sx * sin - cy * sy * cos)
        });
        */







    </script>
</body>
</html>