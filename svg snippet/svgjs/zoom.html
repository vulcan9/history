<!DOCTYPE html>

<html lang="ko" xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8" />
	<title>svg.js 라이브러리 test</title>

    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>

    <!--
    <script src="https://s3-eu-west-1.amazonaws.com/svgjs/svg.js" type="text/javascript" charset="utf-8"></script>
    <script src="http://svgjs.com/javascripts/svg.draggable.js" type="text/javascript" charset="utf-8"></script>
    <script src="http://svgjs.com/javascripts/svg.easing.js" type="text/javascript" charset="utf-8"></script>
    -->
    
    
    <style>
        body, div{font-size:0;}
        svg {
            font-size: 12px;
            border: 1px dashed #000;
            background: #ddd;
        }
        g {
            pointer-events: bounding-box;
        }
            g.viewport .background {
                opacity: 0.1;
                fill: #777;
            }
                g.viewport .background:hover {
                    opacity: 0.2;
                }
            g.gArea .background {
                opacity: 0;
                fill: none;
                stroke: #00c1ff;
                stroke-width: 1px;
            }

                g.gArea .background:hover {
                    opacity: 0.5;
                }

        text {
            pointer-events: none;
        }
        rect {
            /*fill: #b6ff00;*/
            stroke-width: 1px;
            cursor: pointer;
            opacity: 0.5;
        }
            rect:hover {
                opacity: 1;
            }

    </style>
</head>
<body>

	<!--
	<svg width="50" height="50">
		<circle cx="25" cy="25" r="25" fill="purple" />
	</svg>
	-->
	<div id="container" class="aa" style="
	position: absolute; background-color:#EEE; padding:10px;
    left: 20px;
    top: 20px;"></div>

    
	<script src="../_unit/ScaleMode.js"></script>
    <script src="src/svg.js"></script>
    <script src="src/svg.easing.js"></script>
    <!--<script src="src/svg.draggable.js"></script>
    <script src="src/svg.absorb.js"></script> // svg 객체를 이미지처럼 삽입 -->
    <!--<script src="src/svg.filter.js"></script> // 필터 효과 good -->
	
    <script>

        function out() {
            console.log.apply(console, arguments);
        }

        var w = 1500, h = 1000;
        var svg;
        var viewport;
        var padding = 10;

		// 현재 포커싱 받는 객체(group, viewport)
        var currentFocus;
		// 마지막 포커싱 받는 객체(group, viewport)
        var lastFocus;

        // 현재 Scale 값
        var currentScale = 1;

        // focus 동작 무시
        var ignoreFocus = false;

        !function () {

            //--------------------------------
            // SVG
            //--------------------------------

            if (SVG.supported == false) {
                alert('SVG not supported');
                return;
            }

            svg = SVG("container").fixSubPixelOffset().size(w, h)
                //.style("margin-bottom", "10px");

            // 마우스 이벤트
            screenMouse(svg, {
                click: function () {
                    out("# svg 클릭");
                    focus(this);
                }
            });

            viewport = svg.group().addClass("viewport")
                .move(padding, padding);
            viewport.rect().addClass("background")
                .size(w - padding * 2, h - padding * 2);

            // 마우스 이벤트
            var moveFx = null;
            screenMouse(viewport, {
                click: function () {
                    out("# viewport 클릭");
                    focus(this);
                },
                move: function (e, dx, dy) {
                    if (currentFocus == viewport) return;
                    //out(dx, dy);
                    
                    /*
                    // viewport.dmove(dx, dy);
                    // transform으로 이동 시켜야함

                    [이동]
                    |1 0 cx|| a c e |   | a c e+dx |
                    |0 1 cy|| b d f | = | b d f+dy |
                    |0 0  1|| 0 0 1 |   | 0 0    1 |
                    */
                    var m = viewport.trans;
                    moveFx = viewport.transform({
                        a: m.a,
                        b: m.b,
                        c: m.c,
                        d: m.d,
                        e: m.e + dx,
                        f: m.f + dy
                    });
                    
                },
                /*
                down: function (e) {

                    if (moveFx) {
                        ignoreFocus = true;
                        moveFx.stop();
                        moveFx = null;
                    }
                },
                up: function (e, tx, ty) {
                    if (currentFocus == viewport) return;

                    if(tx == 0 && ty == 0) return;
                    // tx, ty :  총 이동량
                    out(tx, ty);
                    var tension = 3;
                    var m = viewport.trans;
                    moveFx = viewport.animate(1000, SVG.easing.quadOut).transform({
                        a: m.a,
                        b: m.b,
                        c: m.c,
                        d: m.d,
                        e: m.e + tx * tension,
                        f: m.f + ty * tension
                    });
                }
                */
            });

            // group 이동 방법
            //var rect = svg.rect().size(100, 100).fill("#FF0");
            //group.add(rect);

            //--------------------------------
            // Group Container 1
            //--------------------------------
            
            var group = createGroup(viewport, 299, 199).translate(50, 50);
            var rect = createElement(group, "rect").fill("#FF0").size(100, 100);
            var rect = createElement(group, "rect").fill("#F00").move(100, 100);

            //--------------------------------
            // Group Container 2
            //--------------------------------

            var group = createGroup(viewport, 160, 160).translate(400, 200).rotate(45);
            var rect = createElement(group, "rect").fill("#FF0").size(80, 80);
            var rect = createElement(group, "rect").fill("#F00").size(80, 80).move(80, 80);

        	// 회전 전 위치
        	//svg.add(group.first().clone().fill("#F00").style("opacity", 0.2).translate(400 + padding, 200 + padding)).style({"pointer-events": "none"});

            //--------------------------------
            // Group Container 3
            //--------------------------------

            var group = createGroup(viewport, 260, 200).translate(200, 100).rotate(90);
            var rect = createElement(group, "rect").fill("#FF0").size(80, 50);
            var rect = createElement(group, "rect").fill("#F00").size(80, 50).move(80, 50);

        	// 회전 전 위치
        	//svg.add(group.first().clone().fill("#FF0").style("opacity", 0.2).translate(300 + padding, 100 + padding)).style({ "pointer-events": "none" });

            ///////////////////////////////////
            // 초기 화면 설정
            ///////////////////////////////////

            // currentFocus값을 설정하기 위해 한번 turn 한다.
            currentScale = 1;
            //currentFocus = viewport;
            focus(viewport.get(2));

        }();

        ///////////////////////////////////
        //
        // Element 관련
        //
        ///////////////////////////////////

        function createGroup(parentGroup, w, h) {
            var group = parentGroup.group().addClass("gArea")

            // 기본 크기 표시
            //group.rect().fill("none")
            group.rect().addClass("background")
                //.stroke({ color: '#f06', width: 1, opacity: 0.5 })
                //.size(w-1, h-1).move(0.5, 0.5);
                .size(w, h);

            /*
            // 마우스 이벤트
            screenMouse(group, {
                click: function () {
                    out("# group 클릭");
                    focus(this);
                }
            });
            */

            return group;
        }

        // var rect = createElement(g, "rect");
        function createElement(parent, type) {
            var el = parent[type]().size(50, 50).fill("#F00");

            // 마우스 이벤트
            screenMouse(el, {
                click: function () {
                    out("# Element 클릭");
                    focus(this);
                }
            });

            //el.draggable()
            return el;
        }

        // var use = group.use(createSymbol("rect"))
        function createSymbol(type) {
            var el = svg.defs()[type](50, 50).fill("#f09");
            return el;
        }

        ///////////////////////////////////
        //
        // 화면 전환 관련
        //
        ///////////////////////////////////

        //--------------------------------
        // FOCUS
        //--------------------------------

        function focus(instance) {
            if (ignoreFocus) {
                ignoreFocus = false;
                return;
            }

            //out(instance);
            var group = getFocusGroup(instance);

            var rollback = (group != instance.parent);
            if (rollback && currentFocus) {
                // 원상태로 되돌리기
                zoom(viewport, 1);
                return;
            }

            // ScaleMode.SCALE_WINDOW
            var source = getBoundary(group);

            var scaleMode = new ScaleMode({
                sourceWidth: source.width,
                sourceHeight: source.height,
                compareWidth: w - padding * 2,
                compareHeight: h - padding * 2
            });

            // scale을 계산한다.
            scaleMode.scale(ScaleMode.SCALE_WINDOW);
            var scale = scaleMode.scale();
            //out("scale : ", scale);

            // Center
            //var pos = getPosition(group, scale);
            //out("position을 계산한다.", pos, source);

            // zoom 적용
            zoom(group, scale);
        }

        function getFocusGroup(instance) {
            var group;

            if (instance == svg) {
                group = instance.first();

            } else if (instance.hasClass("viewport")) {
                // svg (viewport인 경우)
                group = instance;

            } else {
                if (instance.hasClass("gArea")) {
                    // group인 경우
                    group = instance;

                } else if (instance.parent.hasClass("gArea")) {
                    // element인 경우
                    group = instance.parent;

                } else {
                    throw "# FOCUS Target 예외";
                    return;
                }
            }
            return group;
        }

        //--------------------------------
        // Boundary
        // Focus받는 객체의 scale&position 계산을 위해 사용될 boundary를 결정
        //--------------------------------

        var config_fixedBoundary = false;

        // scale 및 위치 설정을 위해 group의 boundary 값을 리턴
        function getBoundary(group) {

            if (config_fixedBoundary) {
                // background 크기(Paper 영역) 기준으로 계산
                // group영역을 넘쳐난 컨텐츠를 가진 경우 확대시 화면에 포함되지 않음
                var box = group.first().bbox();
            } else {
                // group 전체가 차지하는 크기 기준으로 계산할때
                var box = group.bbox();
            }
            
            return box;
        }

        function getWidth(group) {
            return getBoundary(group).width;
        }

        function getHeight(group) {
            return getBoundary(group).height;
        }

        //--------------------------------
        // Position
        // 확대 또는 축소된 화면에서 Focus된 group이 중앙에 위치되도록 하기위해 이동할 거리
        //--------------------------------

		/*
        function getPosition(group, scale) {

            var box = group.bbox();
            var x = box.x * scale - padding;
            var y = box.y * scale - padding;

            // center
            var frame = viewport.bbox();

            var viewportWidth = frame.width / viewport.trans.scaleX;
            var viewportHeight = frame.height / viewport.trans.scaleY;

            var groupWidth = getWidth(group) * scale;
            var groupHeight = getHeight(group) * scale;

            var dx = (viewportWidth - groupWidth) / 2;
            var dy = (viewportHeight - groupHeight) / 2;

            x = x - dx;
            y = y - dy;
            return {x:x, y:y};
        }
		*/

        //--------------------------------
        // move & scale
        //--------------------------------

        // scale = 1로 되돌린 후 다시 zomm 효과를 적용할지 여부
        var config_rollbackEffect = false;

        var config_duration = 1000;
        //var config_easing = SVG.easing.backInOut;
        var config_easing = SVG.easing.cubicOut;

        function zoom(group, scale, after) {

            if (group == currentFocus) {
                out("// TODO : scale이 같은 경우라도 Position을 다시 계산해야 할때도 있다.");
                //if (after) after();
                return;
            }

            if (config_rollbackEffect) {
                if (scale == 1 || !currentFocus || currentFocus == viewport) {
                    zoomExecute(group, scale, after);
                } else {
                    zoomExecute(viewport, 1, function () {
                        zoomExecute(group, scale, after);
                    });
                }
                
            } else {
                zoomExecute(group, scale, after);
            }
        }
        
        var _fx;

        function zoomExecute(group, scale, after) {

            //if (_fx) _fx.stop(true);
            
            lastFocus = currentFocus;
            currentFocus = group;

            var rotation = group.trans.rotation;
            var offset = 0;

            if (currentFocus == viewport) {
                rotation = 0;
                offset = padding;
            }
            
            // 사용할 속성값들

            var box = currentFocus.bbox();
            var cx = box.cx + padding;
            var cy = box.cy + padding;
            var sx = sy = scale;

            var r = -rotation / 180 * Math.PI;
            var cos = Math.cos(r);
            var sin = Math.sin(r);

            /*
            원하는 중심으로 좌표축을 이동 --> 회전시키고 --> 다시 원래의 좌표축으로
            * [-이동] --> [회전] --> [이동] 인 행렬식으로는 다음과 같이 나타남

            [회전]        [-이동]        [회전][-이동]
            | cos -sin 0 || 1 0 -cx |    | cos -sin -cx*cos+cy*sin |
            | sin  cos 0 || 0 1 -cy | =  | sin  cos -cx*sin-cy*cos |
            |   0    0 1 || 0 0   1 |    |   0    0              1 |

            [이동]    [회전][-이동]
            | 1 0 cx || cos -sin -cx*cos+cy*sin |   | cos  -sin  -cx*cos+cy*sin + cx |
            | 0 1 cy || sin  cos -cx*sin-cy*cos | = | sin   cos  -cx*sin-cy*cos + cy |
            | 0 0  1 ||   0    0              1 |   |   0     0                    1 |
            
            .transform({
                a: cos,
                b: sin,
                c: -sin,
                d: cos,
                e: -cx*cos+cy*sin+cx,
                f: -cx*sin-cy*cos+cy
            })

            // 특정위치를 중심으로하는  확대,회전 --> 연산 순서에 주의한다 (변환의 순서에 따라 변환 결과가 다르다.)
            // 순서는 [ x0 y0 1 ] 벡터에 가까운 행렬부터 곱한다고 생각하면 된다

            원하는 중심으로 좌표축을 (확대전 scale 적용된 만큼)이동 --> 확대, 회전 시키고 --> 다시 원래의 좌표축으로 (확대후 scale 적용된 만큼) 이동
            * [-이동] --> [확대] --> [회전] --> [이동] 인 행렬식으로는 다음과 같이 나타남

            // [특정위치를 중심으로하는 확대, 회전] = 
            //     [이동]    [회전]        [확대]     [-이동]     * [좌표]
            |x1|   | 1 0 cx || cos -sin 0 || sx  0 0 || 1 0 -cx |   |x0|
            |y1| = | 0 1 cy || sin  cos 0 ||  0 sy 0 || 0 1 -cy | * |y0|
            | 1|   | 0 0  1 ||   0    0 1 ||  0  0 1 || 0 0   1 |   | 1|
            ----   ----------------------------------------------   -----

            http://aslike.egloos.com/viewer/2898232
            http://blog.naver.com/jjoheejea/150166157777

            [확대]     [-이동]       [확대][-이동]
            | sx  0 0 || 1 0 -cx |   | sx  0 -sx*cx |
            |  0 sy 0 || 0 1 -cy | = |  0 sy -sy*cy |
            |  0  0 1 || 0 0   1 |   |  0  0      1 |

            [회전]        [확대][-이동]      [회전][확대][-이동]
            | cos -sin 0 || sx  0 -sx*cx |   | sx*cos  -sy*sin  cos*(-sx*cx)-sin*(-sy*cy) = SX |
            | sin  cos 0 ||  0 sy -sy*cy | = | sx*sin   sy*cos  sin*(-sx*cx)+cos*(-sy*cy) = SY |
            |   0    0 1 ||  0  0      1 |   |      0        0                               1 |

            _fx.transform({
                a: sx * cos,
                b: sx * sin,
                c: -sy * sin,
                d: sy * cos,
                e: cos * (-sx * cx) - sin * (-sy * cy),
                f: sin * (-sx * cx) + cos * (-sy * cy)
            })

            [이동]         [회전][확대][-이동]       [이동][회전][확대][-이동]
            | 1 0 cx = CX || sx*cos  -sy*sin  SX |   | sx*cos  -sy*sin  SX+CX | 
            | 0 1 cy = CY || sx*sin   sy*cos  SY | = | sx*sin   sy*cos  SY+CY |
            | 0 0       1 ||      0        0  1  |   |      0        0      1 |
            
            _fx.transform({
                a: sx * cos,
                b: sx * sin,
                c: -sy * sin,
                d: sy * cos,
                e: SX + CX,
                f: SY + CY
            })
            
            // 마지막 화면 중심으로 이동
            [중심간격][이동][회전][확대][-이동]
            | 1 0 dx || sx*cos  -sy*sin  SX+CX |   | sx*cos  -sy*sin  SX+CX+dx | 
            | 0 1 dy || sx*sin   sy*cos  SY+CY | = | sx*sin   sy*cos  SY+CY+dy |
            | 0 0  1 ||      0        0      1 |   |      0        0         1 |

            */

            var SX = cos * (-sx * cx) - sin * (-sy * cy);
            var SY = sin * (-sx * cx) + cos * (-sy * cy);
            var CX = cx + offset;
            var CY = cy + offset;

            // 중심점간 거리만큼 이동시켜줌
            var vBox = viewport.bbox();
            var dx = vBox.cx - cx;
            var dy = vBox.cy - cy;

            // SVG.easing
            // https://github.com/wout/svg.easing.js
            // http://easings.net/

            _fx = viewport.animate(config_duration, config_easing);
            _fx.transform({
                a: sx * cos,
                b: sx * sin,
                c: -sy * sin,
                d: sy * cos,
                e: SX + CX + dx,
                f: SY + CY + dy
            })
            .after(function () {
                endEffect(after);
            });

            function endEffect(callback) {
                
                currentScale = scale;

                if (callback) {
                    callback();
                } else {
                    out("# End Effect (scale : ", scale, ") #", currentFocus.attr("id"));
                    
                    //_fx.stop(true);
                    //_fx = null;
                }
            }

        }

        /* 확인된 코드 (rotate 수정 필요)
        _fx = viewport.animate(config_duration, SVG.easing.backOut);
        _fx.rotate(-rotation).scale(scale).translate(-x, -y).after(endEffect);
        
        // 중심점 이동하여 회전
        //viewport.circle(1).fill("#000").center(cx, cy);
        */

        ///////////////////////////////////
        //
        // 마우스 이벤트 관련
        //
        ///////////////////////////////////

        //--------------------------------
        // Drag 화면이동 기능
        //--------------------------------

        // mouse move로 인정되는 이동 민감도
        var moveSensitive = 10;
        var currentMouseTarget = null;

        // eventObj : {down, start, move, up, click} 콜백 함수
        function screenMouse(instance, eventObj) {
            
            if(!eventObj) return;
            var cnt = 0;
            for(var p in eventObj){
                ++cnt;
            }
            if(cnt == 0) return;

            instance.on("mousedown", function (e) {
                if (e.defaultPrevented) return;
                e.preventDefault();

                if (currentMouseTarget) {
                    currentMouseTarget.off("mousemove", onMousemove);
                    currentMouseTarget.off("mouseup", onMouseup);
                }
                currentMouseTarget = this;

                //out("# viewport 클릭");
                //focus(this);
                var isMoveCounter = 0;
                
                out("// TODO : 화면 밖에서 mouseup한 경우도 체크 해야함");

                this.on("mousemove", onMousemove);
                this.on("mouseup", onMouseup);

                if (eventObj.down) eventObj.down.apply(instance, [e]);

                var self = this;
                var startX = startY = oldX = oldY = 0;
                // 총이동량
                var tx = ty = 0;

                function onMousemove(e) {
                    if (e.defaultPrevented) return;
                    e.preventDefault();

                    ++isMoveCounter;
                    if (isMoveCounter < moveSensitive) {
                        return;
                    }

                    if (isMoveCounter == moveSensitive) {
                        if (eventObj.start) eventObj.start.apply(instance, [e]);
                        startX = oldX = e.clientX;
                        startY = oldY = e.clientY;
                    }

                    var dx = e.clientX - oldX;
                    var dy = e.clientY - oldY;

                    if (eventObj.move) eventObj.move.apply(instance, [e, dx, dy]);
                    //out("moveing : ", isMoveCounter);

                    oldX = e.clientX;
                    oldY = e.clientY;
                }

                function onMouseup(e) {
                    if (e.defaultPrevented) return;
                    e.preventDefault();

                    var tx = (startX == 0)? 0 : e.clientX - startX;
                    var ty = (startY == 0)? 0 : e.clientY - startY;
                    if (eventObj.up) eventObj.up.apply(instance, [e, tx, ty]);

                    if (isMoveCounter < moveSensitive) {
                        if (eventObj.click) eventObj.click.apply(instance, [e]);
                    }
                    
                    isMoveCounter = 0;
                    self.off("mousemove", onMousemove);
                    self.off("mouseup", onMouseup);

                    currentMouseTarget = null;
                }
            });

            
        }
        
        

    </script>
</body>
</html>