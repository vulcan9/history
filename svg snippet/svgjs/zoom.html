<!DOCTYPE html>

<html lang="ko" xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8" />
	<title>svg.js 라이브러리 test</title>

    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>

    <!--
    <script src="https://s3-eu-west-1.amazonaws.com/svgjs/svg.js" type="text/javascript" charset="utf-8"></script>
    <script src="http://svgjs.com/javascripts/svg.draggable.js" type="text/javascript" charset="utf-8"></script>
    <script src="http://svgjs.com/javascripts/svg.easing.js" type="text/javascript" charset="utf-8"></script>
    -->
    <script src="src/svg.js"></script>
    <script src="src/svg.easing.js"></script>
    
    <style>
        body, div{font-size:0;}
        svg {
            font-size: 12px;
            border: 1px dashed #000;
            background: #ddd;
        }
        g {
            pointer-events: bounding-box;
        }
            g.viewport .background {
                opacity: 0.1;
                fill: #777;
            }
                g.viewport .background:hover {
                    opacity: 0.2;
                }
            g.gArea .background {
                opacity: 0.5;
                fill: #999;
            }

                g.gArea .background:hover {
                    opacity: 1;
                }

        text {
            pointer-events: none;
        }
        rect {
            /*fill: #b6ff00;*/
            stroke-width: 1px;
            cursor: pointer;
            opacity: 0.5;
        }
            rect:hover {
                opacity: 1;
            }

    </style>
</head>
<body>

	<!--
	<svg width="50" height="50">
		<circle cx="25" cy="25" r="25" fill="purple" />
	</svg>
	-->
	<div id="container" class="aa" style="
	position: absolute; background-color:#EEE; padding:10px;
    left: 20px;
    top: 20px;"></div>

	<script src="../_unit/ScaleMode.js"></script>
	
    <script>

        function out() {
            console.log.apply(console, arguments);
        }

        var w = 600, h = 400;
        var svg;
        var viewport;
        var padding = 10;

        // 현재 포커싱 받는 객체(group)
        var currentFocus;

        !function () {

            //--------------------------------
            // SVG
            //--------------------------------

            if (SVG.supported == false) {
                alert('SVG not supported');
                return;
            }

            svg = SVG("container").fixSubPixelOffset().size(w, h)
                //.style("margin-bottom", "10px");

            svg.on("mousedown", function (e) {
                if (e.defaultPrevented) return;
                out("# svg 클릭");
                focus(this);
            });

            viewport = svg.group().addClass("viewport")
                .move(padding, padding);
            viewport.rect().addClass("background")
                .size(w - padding * 2, h - padding * 2);

            viewport.on("mousedown", function (e) {
                if (e.defaultPrevented) return;
                e.preventDefault();
                out("# viewport 클릭");
                focus(this);
            });

            // group 이동 방법
            //var rect = svg.rect().size(100, 100).fill("#FF0");
            //group.add(rect);

            //--------------------------------
            // Group Container 1
            //--------------------------------
            
            var group = createGroup(viewport, 299, 199).translate(50, 50);
            var rect = createElement(group, "rect").fill("#FF0").size(100, 100);
            var rect = createElement(group, "rect").fill("#F00").move(100, 100);

            //--------------------------------
            // Group Container 2
            //--------------------------------

            var group = createGroup(viewport, 160, 160).translate(400, 200).rotate(45);
            var rect = createElement(group, "rect").fill("#FF0").size(100, 100);
            var rect = createElement(group, "rect").fill("#F00").move(100, 100);

            //--------------------------------
            // Group Container 3
            //--------------------------------

            var group = createGroup(viewport, 160, 100).translate(300, 100).rotate(45);
            var rect = createElement(group, "rect").fill("#FF0").size(100, 100);
            var rect = createElement(group, "rect").fill("#F00").move(100, 100);

            ///////////////////////////////////
            // Function
            ///////////////////////////////////

            function createGroup(parentGroup, w, h) {
                var group = parentGroup.group().addClass("gArea")

                // 기본 크기 표시
                //group.rect().fill("none")
                group.rect().addClass("background")
                    //.stroke({ color: '#f06', width: 1, opacity: 0.5 })
                    //.size(w-1, h-1).move(0.5, 0.5);
                    .size(w, h);

                group.on("mousedown", function (e) {
                    if (e.defaultPrevented) return;
                    e.preventDefault();
                    out("# parent Group 클릭");
                    focus(this);
                });

                return group;
            }
            
            // var rect = createElement(g, "rect");
            function createElement(parent, type) {
                var el = parent[type]().size(50, 50).fill("#F00");
                
                el.on("mousedown", function (e) {
                    e.preventDefault();
                    out("# Element 클릭");
                    focus(this);
                });

                return el;
            }
            
            // var use = group.use(createSymbol("rect"))
            function createSymbol(type) {
                var el = svg.defs()[type](50, 50).fill("#f09");
                return el;
            }

            //--------------------------------
            // FOCUS
            //--------------------------------

            var currentScale = 1;

            function focus(instance) {
                
                //out(instance);
                var group = getFocusGroup(instance);

                var rollback = (group != instance.parent);
                if (rollback) {
                    // 원상태로 되돌리기
                    currentFocus = viewport;
                    initZoom();
                    return;
                }

                if (group == currentFocus) return;
                currentFocus = group;

                // ScaleMode.SCALE_WINDOW
                var source = getBoundary(group);
                
                var scaleMode = new ScaleMode({
                    sourceWidth: source.width,
                    sourceHeight: source.height,
                    compareWidth: w - padding*2,
                    compareHeight: h - padding*2
                });

                // scale을 계산한다.
                scaleMode.scale(ScaleMode.SCALE_WINDOW);
                var scale = scaleMode.scale();
                out("scale : ", scale);

                // Rotate
                var rotation = group.trans.rotation;

                // Center
                var pos = getPosition(group, scale);
                out("position을 계산한다.", pos, source);

                // zoom 적용
                zoom(scale, pos.x, pos.y, rotation);
            }

            function getFocusGroup(instance) {
                var group;

                if (instance == svg) {
                    group = instance.first();

                } else if (instance.hasClass("viewport")) {
                    out("// svg (viewport인 경우)");
                    group = instance;

                } else {
                    if (instance.hasClass("gArea")) {
                        out("// group인 경우");
                        group = instance;

                    } else if (instance.parent.hasClass("gArea")) {
                        out("// element인 경우");
                        group = instance.parent;

                    } else {
                        throw "# FOCUS 예외";
                        return;
                    }
                }
                return group;
            }
        }();

        //--------------------------------
        // Boundary
        // Focus받는 객체의 scale&position 계산을 위해 사용될 boundary를 결정
        //--------------------------------

        var config_fixedBoundary = false;

        // scale 및 위치 설정을 위해 group의 boundary 값을 리턴
        function getBoundary(group) {

            if (config_fixedBoundary) {
                // background 크기(Paper 영역) 기준으로 계산
                // group영역을 넘쳐난 컨텐츠를 가진 경우 확대시 화면에 포함되지 않음
                var box = group.first().bbox();
            } else {
                // group 전체가 차지하는 크기 기준으로 계산할때
                var box = group.bbox();
            }
            
            return box;
        }

        function getWidth(group) {
            return getBoundary(group).width;
        }

        function getHeight(group) {
            return getBoundary(group).height;
        }

        //--------------------------------
        // Position
        // 확대 또는 축소된 화면에서 Focus된 group이 중앙에 위치되도록 하기위해 이동할 거리
        //--------------------------------

        function getPosition(group, scale) {

            var box = group.bbox();
            var x = box.x * scale - padding;
            var y = box.y * scale - padding;

            // center
            var frame = viewport.bbox();

            var viewportWidth = frame.width / viewport.trans.scaleX;
            var viewportHeight = frame.height / viewport.trans.scaleY;

            var groupWidth = getWidth(group) * scale;
            var groupHeight = getHeight(group) * scale;

            var dx = (viewportWidth - groupWidth) / 2;
            var dy = (viewportHeight - groupHeight) / 2;

            x = x - dx;
            y = y - dy;
            return {x:x, y:y};
        }

        //--------------------------------
        // move & scale
        //--------------------------------

        // scale = 1로 되돌린 후 다시 zomm 효과를 적용할지 여부
        var config_rollbackEffect = false;

        function initZoom() {
            //if (viewport.trans.scaleX == 1) return;
            var scale = 1;
            var x = -padding;
            var y = -padding;
            var rotation = 0;
            zoom(1, x, y, rotation);
        }

        var _fx;

        /*
        // SVG.easing
        // https://github.com/wout/svg.easing.js
        // http://easings.net/
        */

        function zoom(scale, x, y, rotation) {
            if (_fx) {
                _fx.stop();
            }

            var duration = 1000;
            if (viewport.trans.scaleX == 1 || !config_rollbackEffect) {

                /* 확인된 코드 (rotate 수정 필요)
                _fx = viewport.animate(duration, SVG.easing.backOut);
                _fx.scale(scale).translate(-x, -y).rotate(-rotation).after(endEffect);
                */




                /*
                c = svg.rect().size(160, 150).fill("#0F0").style("opacity", 0.2);
                var cx = 160 / 2, cy = 150 / 2;
                c.transform({
                    rotation: 45,
                    cx: -300, cy: -100
                }).move(292, -454);
                */


                
                var g = viewport.get(2);
                out("G : ", g);
                var k = g.bbox();
                out("K : ", k, g.x());
                /*
                // rotation, scale 중심점을 현재 group의 center로 설정한다.
                scale = 1;
                var cx = k.cx, cy = k.cy;
                var r = g.trans.rotation;
                _fx = viewport.animate()
                    .rotate(-r, cx, cy).during(function (pos, morph) {
                        //var s = (scale + scale * pos) / 2;
                        //viewport.scale(s);
                    })


                    */

                ?????????????
                _fx = viewport.animate(duration, SVG.easing.backOut);
                _fx.scale(scale).translate(-x+100, -y+100).rotate(-rotation).after(endEffect);













            } else {
                // 초기 상태로 복귀한 후 Zoom 적용
                _fx = viewport.animate(duration, SVG.easing.backInOut);

                _fx.scale(1).translate(padding, padding).rotate(-rotation).after(function () {
                    _fx.stop();
                    _fx = viewport.animate(duration, SVG.easing.backOut);
                    _fx.scale(scale).translate(-x, -y).after(endEffect);
                });
            }

            function endEffect() {
                // 중복 실행 방지되도록 수정
                _fx.stop();

                out("endEffect : ", scale);
                _fx = null;
            }
        }

        //--------------------------------
        // Drag 화면이동 기능
        //--------------------------------

        b = svg.rect().size(100, 100).fill("#0FF").style("opacity", 0.2).rotate(45, 10, 10);
        out("b : ",b.bbox());
        //b.rotate(45, 0, 0);
        //b.move(100, 0);

        //--------------------------------
        // Rotation된 화면 표시
        //--------------------------------

        a = svg.rect().size(100, 100).fill("#F00").style("opacity", 0.2);
        a.rotate(45, 0, 0)//.move(25,0);

        /*
        // http://belouder.blog.me/40163175484
        // http://blog.jidolstar.com/463

                              | 1 3 5 |   | a c e |   | Sx Tx dx |
        matrix[1,2,3,4,5,6] = | 2 4 6 | = | b d f | = | Ty Sy dy |
                              | 0 0 1 |   | 0 0 1 |   | 0  0   1 |
        
        // rotate인 경우
        | cos -sin 0 |
        | sin  cos 0 |
        |   0    0 1 |

        // 중심점 이동->회전->확대/축소를 적용
        [ sx * cosθ,  sx * sinθ, -cx * sx * cosθ - cy * sx * sinθ], 
        [-sy * sinθ,  sy * cosθ,  cx * sy * sinθ + cy * sy * cosθ], 
        [          0,           0,                                  1]
        

        이동      회전         확대/축소
        | 1 0 -cx |  cos sin 0 | sx  0 0 |
        | 0 1 -cy | -sin cos 0 |  0 sy 0 |
        | 0 0 1   |    0   0 1 |  0  0 1 |
        ==>
        |  cos sin -cx | sx  0 0 |
        | -sin cos -cy |  0 sy 0 |
        |    0   0   1 |  0  0 1 |
        ==>
        |  cos*sx sin*sy -cx |
        | -sin*sx cos*sy -cy |
        |       0      0   1 |

        */
        //a.transform({matrix:"1,0,0,1,0,0"})

        var r = 45 / 180 * Math.PI;
        //a.transform({ matrix: "1,0,0,1,10,0" })
        var cos = Math.cos(r);
        var sin = Math.sin(r);
        var sx = sy = 1;
        var cx = cy = 10;
        /*
        a.transform({
            a: (sx * cos), c: (sx * sin), e: (-cx * sx * cos - cy * sx * sin),
            b: (-sy * sin), d: (sy * cos), f: (cx * sy * sin + cy * sy * cos)
        });
        
        a.transform({
            a: (sx * cos), c: (sy * sin), e: (-cx * sx * cos + cy * sy * sin),
            b: (-sx * sin), d: (sy * cos), f: (-cx * sx * sin - cy * sy * cos)
        });
        */
        a.transform({
            rotation: 45,
            cx:cx, cy:cy
        });







    </script>
</body>
</html>